import os
import cv2
import numpy as np

def split_image(image, num_rows, num_cols):
    # 獲取圖像的高度和寬度
    height, width = image.shape[:2]
    # 計算每個區塊的高度和寬度
    block_height = height // num_rows
    block_width = width // num_cols
    # 存儲所有區塊的列表
    blocks = []
    for r in range(num_rows):
        for c in range(num_cols):
            # 計算當前區塊的範圍
            start_row = r * block_height
            end_row = (r + 1) * block_height
            start_col = c * block_width
            end_col = (c + 1) * block_width
            # 提取當前區塊
            block = image[start_row:end_row, start_col:end_col]
            blocks.append(block)
    return blocks , height , width
def match_features(query_image, train_images):#query是大地圖
    # 初始化 SIFT 檢測器
    sift = cv2.SIFT_create()
    # 使用 SIFT 找到 大地圖 的關鍵點和描述子
    kp1, des1 = sift.detectAndCompute(query_image, None)
    # 創建 FLANN 匹配器
    flann = cv2.FlannBasedMatcher()
    # 儲存所有匹配的結果
    all_matches = []
    for train_image in train_images:
        # 使用 SIFT 找到 小地圖 的關鍵點和描述子
        kp2, des2 = sift.detectAndCompute(train_image, None)
        # 進行特徵匹配
        matches = flann.knnMatch(des1, des2, k=2)
        # 剔除不好的匹配
        good_matches = []
        for m, n in matches:
            if m.distance < 0.7 * n.distance:
                good_matches.append(m)
        all_matches.append(len(good_matches))
    return all_matches ,good_matches,kp1 ,kp2

def find_most_matched_block(matches,good_matches,kp1,kp2):
    most_matched_block_index = np.argmax(matches)
    #homographty
    if len(good_matches) > 10:
        src_pts = np.float32([kp1[m.queryIdx].pt for m in good_matches]).reshape(-1, 1, 2)
        dst_pts = np.float32([kp2[m.trainIdx].pt for m in good_matches]).reshape(-1, 1, 2)
        M, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)
        matchesMask = mask.ravel().tolist()
        # 使用透視變換將小地圖上的特徵點映射到大地圖上
        big_map_keypoint = cv2.perspectiveTransform(dst_pts, M)
        print("在小地圖上的特徵點座標：", dst_pts.squeeze())
        print("映射到大地圖上的特徵點座標：", big_map_keypoint.squeeze())
    return most_matched_block_index
def find_surrounding_indices(most_matched_block_index, num_rows, num_cols):
    row_index = most_matched_block_index // num_cols
    col_index = most_matched_block_index % num_cols

    surrounding_indices = []
    for dr in range(-1, 2):
        for dc in range(-1, 2):
            r = row_index + dr
            c = col_index + dc
            if (dr != 0 or dc != 0) and 0 <= r < num_rows and 0 <= c < num_cols:
                surrounding_indices.append(r * num_cols + c)

    return surrounding_indices

# def find_most_matched_block(matches):
#     most_matched_block_index = np.argmax(matches)
#     num_cols = 6  # Assuming columns as per your previous code
#     # Calculate row and column index of the most matched block
#     row_index = most_matched_block_index // num_cols
#     col_index = most_matched_block_index % num_cols
#
#     # Get indices of surrounding blocks
#     surrounding_indices = []
#     for dr in range(-1, 2):
#         for dc in range(-1, 2):
#             r = row_index + dr
#             c = col_index + dc
#             # Check if the indices are within bounds
#             # 排除最匹配區塊本身和超出邊界的區塊
#             if (dr != 0 or dc != 0) and 0 <= r < num_rows and 0 <= c < num_cols:
#                 surrounding_indices.append(r * num_cols + c)
#
#     return most_matched_block_index, surrounding_indices

# 定義函數來將索引與對應的區塊匹配並返回結果列表
def match_indices_with_third_image(indices, third_image):
    matches_list = []
    for index in indices:
        # 確認索引是否在範圍內
        if 0 <= index < len(blocks):
            # 取得對應的區塊
            block = blocks[index]
            # 進行特徵匹配
            matches = match_features(third_image, [block])
            matches_list.append((index, matches))
    return matches_list

def show_matched_blocks(query_image, matched_indices, blocks):
    for index in matched_indices:
        if 0 <= index < len(blocks):
            block = blocks[index]
            cv2.imshow(f'Matched Block {index}', block)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
def merge_blocks_into_one_image(blocks, num_rows, num_cols):
    block_height, block_width = blocks[0].shape[:2]
    merged_image = np.zeros((num_rows * block_height // 2, num_cols * block_width // 2, 3), dtype=np.uint8)
    for r in range(num_rows):
        for c in range(num_cols):
            block_index = r * num_cols + c
            block = cv2.resize(blocks[block_index], (block_width // 2, block_height // 2))  # Resize each block
            merged_image[r * block_height // 2:(r + 1) * block_height // 2, c * block_width // 2:(c + 1) * block_width // 2] = block
    return merged_image
big_map_img = cv2.imread("0313/0313/jpg/14/23/23-1.jpg")
# 指定要分割的行和列數
num_rows = 6
num_cols = 6
new_num_rows = 3
new_num_cols = 3
blocks ,height , width= split_image(big_map_img, num_rows, num_cols)
# print(blocks)
output_folder_name = "output_frames"
num = len(os.listdir("output_frames"))
def main(blocks):
    for i in range(1, num+1):
        image = cv2.imread(f'{output_folder_name}/frame_{i-1}.jpg')
        matches ,good_matches, kp1, kp2 = match_features(image, blocks)
        most_matched_block_index = find_most_matched_block(matches,good_matches ,kp1,kp2)
        surrounding_indices = find_surrounding_indices(most_matched_block_index, num_rows, num_cols)
        if i>1:
            surrounding_indices = find_surrounding_indices(most_matched_block_index, new_num_rows, new_num_cols)
        else:
            pass
        print(surrounding_indices)
        # most_matched_block_index, surrounding_indices = find_most_matched_block(matches)
        # 取得最匹配的區塊以及其周圍的區塊
        most_matched_block = blocks[most_matched_block_index]
        surrounding_blocks = [blocks[i] for i in surrounding_indices]
        # 將最匹配的區塊和周圍的區塊合併為一個列表
        blocks_to_match = [most_matched_block] + surrounding_blocks
        block_indices = []
        for i, block_to_match in enumerate(blocks_to_match):
            # 初始化索引
            block_index = None
            # 尋找 block_to_match 在 blocks 中的索引
            for j, block in enumerate(blocks):
                # 如果兩個陣列相等，則找到索引
                if np.array_equal(block_to_match, block):
                    block_index = j
                    break

            if block_index is not None:
                block_indices.append(block_index)
                print(f"區塊 {i}: 在 blocks 中的索引 = {block_index}")
            else:
                print(f"區塊 {i}: 找不到在 blocks 中的對應索引")
        block_indices_sorted = sorted(block_indices)
        # show_matched_blocks(image, block_indices_sorted, blocks)
        merged_image = merge_blocks_into_one_image([blocks[index] for index in block_indices_sorted], 3, 3)
        cv2.imshow('Merged Image', merged_image)
        cv2.waitKey(0)
        sorted_blocks = [blocks[index] for index in block_indices_sorted]
        blocks = sorted_blocks
main(blocks)

cv2.waitKey(0)
cv2.destroyAllWindows()
